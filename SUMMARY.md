# Summary

* [Introduction](README.md)
* [1 Introduction](01/README.md)
    * [1.1 Language Processors](01/1.1.md)
    * [1.2 The Structure of a Compiler](01/1.2.md)
    * [1.3 The Evolution of Programming Languages](01/1.3.md)
    * [1.4 The Science of Building a Compiler](01/1.4.md)
    * [1.5 Applications of Compiler Technology](01/1.5.md)
    * [1.6 Programming Language Basics](01/1.6.md)
* [2 A Simple Syntax-Directed Translator](02/README.md)
    * [2.1 Introduction](02/2.1.md)
    * [2.2 Syntax Definition](02/2.2.md)
    * [2.3 Syntax-Directed Translation](02/2.3.md)
    * [2.4 Parsing](02/2.4.md)
    * [2.5 A Translator for Simple Expression](02/2.5.md)
    * [2.6 Lexical Analysis](02/2.6.md)
    * [2.7 Symbol Tables](02/2.7.md)
    * [2.8 Intermediate Code Generation](02/2.8.md)
* [3 Lexical Analysis](03/README.md)
    * [3.1 The Role of the Lexical Analyzer](03/3.1.md)
    * [3.2 Input Buffering](03/3.2.md)
    * [3.3 Specification of Tokens](03/3.3.md)
    * [3.4 Recognition of Tokens](03/3.4.md)
    * [3.5 The Lexical-Analyzer Generator Lex](03/3.5.md)
    * [3.6 Finite Automata](03/3.6.md)
    * [3.7 From Regular Expressions to Automata](03/3.7.md)
    * [3.8 Design of a Lexical-Analyzer Generator](03/3.8.md)
    * [3.9 Optimization of DFA-Based Pattern Matches](03/3.9.md)
* [4 Syntax Analysis](04/README.md)
    * [4.1 Introduction](04/4.1.md)
    * [4.2 Context-Free Grammars](04/4.2.md)
    * [4.3 Writing a Grammar](04/4.3.md)
    * [4.4 Top-Down Parsing](04/4.4.1.md)
    * [4.4 Top-Down Parsing](04/4.4.2.md)
    * [4.5 Bottom-Up Parsing](04/4.5.md)
    * [4.6 Introduction to LR Parsing: Simple LR](04/4.6.md)
    * [4.7 More Powerful LR Parsers](04/4.7.md)
    * [4.8 Using Ambiguous Grammars](04/4.8.md)
    * [4.9 Parser Generators](04/4.9.md)
* [5 Syntax-Directed Translation](05/README.md)
    * [5.1 Syntax-Directed Definitions](05/5.1.md)
    * [5.2 Evaluation Orders for SDD's](05/5.2.md)
    * [5.3 Applications of Syntax-Directed Translation](05/5.3.md)
    * [5.4 Syntax-Directed Translation Schemes](05/5.4.md)
    * [5.5 Implementing L-Attributed SDD's](05/5.5.md)
* [6 Intermediate-Code Generation](06/README.md)
    * [6.1 Variants of Syntax Trees](06/6.1.md)
    * [6.2 Three-Address Code](06/6.2.md)
    * [6.3 Types and Declarations](06/6.3.md)
    * [6.4 Translation of Expressions](06/6.4.md)
    * [6.5 Type Checking](06/6.5.md)
    * [6.6 Control Flow](06/6.6.md)
    * [6.7 Backpatching](06/6.7.md)
    * [6.8 Switch-Statements](06/6.8.md)
    * [6.9 Intermediate Code for Procedures](06/6.9.md)
* [7 Run-Time Environments](07/README.md)
    * [7.1 Storage Organization](07/7.1.md)
    * [7.2 Stack Allocation of Space](07/7.2.md)
    * [7.3 Access to Nonlocal Data on the Stack](07/7.3.md)
    * [7.4 Heap Management](07/7.4.md)
    * [7.5 Introduction to Garbage Collection](07/7.5.md)
    * [7.6 Introduction to Trace-Based Collection](07/7.6.md)
    * [7.7 Short-Pause Garbage Collection](07/7.7.md)
    * [7.8 Advanced Topics in Garbage Collection](07/7.8.md)
* [8 Code Generation](08/README.md)
    * [8.1 Issues in the Design of a Code Generator](08/8.1.md)
    * [8.2 The Target Language](08/8.2.md)
    * [8.3 Addresses in the Target Code](08/8.3.md)
    * [8.4 Basic Blocks and Flow Graphs](08/8.4.md)
    * [8.5 Optimization of Basic Blocks](08/8.5.md)
    * [8.6 A Simple Code Generator](08/8.6.md)
    * [8.7 Peephole Optimization](08/8.7.md)
    * [8.8 Register Allocation and Assignment](08/8.8.md)
    * [8.9 Instruction Selection by Tree Rewriting](08/8.9.md)
    * [8.10 Optimal Code Generation for Expressions](08/8.10.md)
    * [8.11 Dynamic Programming Code-Generation](08/8.11.md)
* [9 Machine-Independent Optimizations](09/README.md)
    * [9.1 The Principal Sources of Optimization](09/9.1.md)
    * [9.2 Introduction to Data-Flow Analysis](09/9.2.md)
    * [9.3 Foundations of Data-Flow Analysis](09/9.3.md)
    * [9.4 Constant Propagation](09/9.4.md)
    * [9.5 Partial-Redundancy Elimination](09/9.5.md)
    * [9.6 Loops in Flow Graphs](09/9.6.md)
    * [9.7 Region-Based Analysis](09/9.7.md)
    * [9.8 Symbolic Analysis](09/9.8.md)
* [10 Instruction-Level Parallelism](10/README.md)
    * [10.1 Processor Architectures](10/10.1.md)
    * [10.2 Code-Scheduling Constraints](10/10.2.md)
    * [10.3 Basic-Block Scheduling](10/10.3.md)
    * [10.4 Global Code Scheduling](10/10.4.md)
    * [10.5 Software Pipelining](10/10.5.md)
* [11 Optimizing for Parallelism and Locality](11/README.md)
    * [11.1 Basic Concepts](11/11.1.md)
    * [11.2 Matrix Multiply: An In-Depth Example](11/11.2.md)
    * [11.3 Iteration Spaces](11/11.3.md)
    * [11.4 Affine Array Indexes](11/11.4.md)
    * [11.5 Data Reuse](11/11.5.md)
    * [11.6 Array Data-Dependence Analysis](11/11.6.md)
    * [11.7 Finding Synchronization-Free Parallelism](11/11.7.md)
    * [11.8 Synchronization Between Parallel Loops](11/11.8.md)
    * [11.9 Pipelining](11/11.9.md)
    * [11.10 Locality Optimizations](11/11.10.md)
    * [11.11 Other Uses of Affine Transforms](11/11.11.md)
* [12 Interprocedural Analysis](12/README.md)
    * [12.1 Basic Concepts](12/12.1.md)
    * [12.2 Why Interprocedural Analysis?](12/12.2.md)
    * [12.3 A Logical Representation of Data Flow](12/12.3.md)
    * [12.4 A Simple Pointer-Analysis Algorithm](12/12.4.md)
    * [12.5 Context-Insensitive Interprocedural Analysis](12/12.5.md)
    * [12.6 Context-Sensitive Pointer Analysis](12/12.6.md)
    * [12.7 Datalog Implementation by BDD's](12/12.7.md)

