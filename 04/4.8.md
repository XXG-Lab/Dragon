## 4.8 Using Ambiguous Grammars

### 4.8.1

> The following is an ambiguous grammar for expressions with $$n$$ binary, infix operators, at $$n$$ different levels of precedencce:

> $$
E~\rightarrow~E~\theta_1~E~|~E~\theta_2~E~|~\cdots~|~E~\theta_n~E~|~(~E~)~|~\mathbf{id}
$$

> a) As a function of $$n$$, what are the SLR sets of items?

$$6 + 2n$$

> b) How would you resolve the conflicts in the SLR items so that all operators are left associative, and $$\theta_n$$ takes precedence over $$\theta_{n-1}$$, which takes precedence over $$\theta_{n-2}$$, and so on?

Shift when the item is constructed by $$E~\rightarrow~E~\theta_i~E$$ followed by $$\theta_j$$ and $$i < j$$, otherwise reduce.

> c) Show the SLR parsing table that results from your decisions in part (b).

| State | $$($$ | $$)$$ | $$\theta_1$$ | $$\theta_2$$ | $$\cdots$$ | $$\theta_n$$ | $$\mathbf{id}$$ | $$\$$$ | $$E$$ |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| $$0$$ | $$s_2$$ | | | | | | $$s_3$$ | | $$1$$ |
| $$1$$ | | | $$s_4$$ | $$s_5$$ | | $$s_n$$ | | acc | |
| $$2$$ | $$s_2$$ | | | | | | $$s_3$$ | | $$n + 4$$ |
| $$3$$ | | $$r(~E~\rightarrow~\mathbf{id}~)$$ | $$r(~E~\rightarrow~\mathbf{id}~)$$ | $$r(~E~\rightarrow~\mathbf{id}~)$$ | $$r(~E~\rightarrow~\mathbf{id}~)$$ | $$r(~E~\rightarrow~\mathbf{id}~)$$ |  | $$r(~E~\rightarrow~\mathbf{id}~)$$ | |
| $$4$$ | $$s_2$$ | | | | | | $$s_3$$ | | $$n + 5$$ |
| $$5$$ | $$s_2$$ | | | | | | $$s_3$$ | | $$n + 6$$ |
| $$\cdots$$ | $$s_2$$ | | | | | | $$s_3$$ | | |
| $$n + 3$$ | $$s_2$$ | | | | | | $$s_3$$ | | $$2n + 2$$ |
| $$n + 4$$ | | $$s_{2n+5}$$ | $$s_4$$ | $$s_5$$ | | $$s_{n + 3}$$ | | | |
| $$n + 5$$ | | $$r(~E~\rightarrow~E~\theta_1~E~)$$ | $$r(~E~\rightarrow~E~\theta_1~E~)$$ | $$s_5$$ | | $$s_{n + 3}$$ | | $$r(~E~\rightarrow~E~\theta_1~E~)$$ | |
| $$n + 6$$ | | $$r(~E~\rightarrow~E~\theta_2~E~)$$ | $$r(~E~\rightarrow~E~\theta_2~E~)$$ | $$r(~E~\rightarrow~E~\theta_2~E~)$$ | | $$s_{n + 3}$$ | | $$r(~E~\rightarrow~E~\theta_2~E~)$$ | |
| $$\cdots$$ | | | | | | | | | |
| $$2n + 4$$ | | $$r(~E~\rightarrow~E~\theta_n~E~)$$ | $$r(~E~\rightarrow~E~\theta_n~E~)$$ | $$r(~E~\rightarrow~E~\theta_n~E~)$$ | $$r(~E~\rightarrow~E~\theta_n~E~)$$ | $$r(~E~\rightarrow~E~\theta_n~E~)$$ | $$r(~E~\rightarrow~E~\theta_n~E~)$$ | |
| $$2n + 5$$ | | $$r(~E~\rightarrow~(~E~)~)$$ | $$r(~E~\rightarrow~(~E~)~)$$ | $$r(~E~\rightarrow~(~E~)~)$$ | $$r(~E~\rightarrow~(~E~)~)$$ | $$r(~E~\rightarrow~(~E~)~)$$ | | $$r(~E~\rightarrow~(~E~)~)$$ | |

[SLR(1)](https://cyberzhg.github.io/toolbox/lr0?grammar=RSAtPiBFIM64MSBFCiAgIHwgRSDOuDIgRQogICB8IEUgzrgzIEUKICAgfCAoIEUgKQogICB8IGlkCg==)

> d) Repeat parts (a) and (c) for the unambiguous grammar, which defines the same set of expressions, shown in Fig. 4.55.

$$6 + 3n$$ items.

[SLR(1)](https://cyberzhg.github.io/toolbox/lr0?grammar=RTEgLT4gRTEgzrgxIEUyIHwgRTIKRTIgLT4gRTIgzrgyIEUzIHwgRTMKRTMgLT4gRTMgzrgzIEU0IHwgRTQKRTQgLT4gKCBFMSApIHwgaWQ=)

> e) How do you counts of the number of sets of items and the sizes of the tables for the two (ambiguous and unambiguous) grammars compare? What does that comparison tell you about the use of ambiguous expression grammars?

The parsing table generated by an ambiguous grammar has a smaller size than the unambiguous one.

### 4.8.2

> In Fig. 4.56 is a grammar for certain statements, similar to that discussed in Exercise 4.4.12. Again, $$e$$ and $$s$$ are  terminals standing for conditional expressions and "other statements", respectively.

> a) Build and LR parsing table for this grammar, resolving conflicts in the usual way for the dangling-else problem.

[SLR(1)](https://cyberzhg.github.io/toolbox/lr0?grammar=c3RtdCAtPiBpZiBlIHRoZW4gc3RtdAogICAgICB8IGlmIGUgdGhlbiBzdG10IGVsc2Ugc3RtdAogICAgICB8IHdoaWxlIGUgZG8gc3RtdAogICAgICB8IGJlZ2luIGxpc3QgZW5kCiAgICAgIHwgcwpsaXN0IC0+IGxpc3QgOyBzdG10CiAgICAgIHwgc3RtdA==)

The conflict could be resolved by choosing $$s_{17}$$ in state 14.

> b) Implement error correction by filling in the blank entries in the parsing table with extra reduce-actions or suitable error-recovery routines.

> c) Show the behavior of your parser on the following inputs:

> (i) $$\mathbf{if}~e~\mathbf{then}~s~;~\mathbf{if}~e~\mathbf{then}~s~\mathbf{end}$$

Unexpected ';'.

> (ii) $$\mathbf{while}~e~\mathbf{do}~\mathbf{begin}~s~;~\mathbf{if}~e~\mathbf{then}~s~;~\mathbf{end}$$

Expect 'stmt', found 'end'.
